# Bug修复报告 - 2024-11-02

## 修复的问题

### 1. ✅ 删除订阅后可以再次导入

**问题描述**：
- 导入订阅时设置了禁止重复导入的检查
- 但删除订阅后，由于元数据未清理，导致无法再次导入相同的订阅URL

**根本原因**：
- `ConfigScreenNew.kt` 中删除订阅时只调用了 `profileManager.deleteProfile(file)` 删除配置文件
- 但没有调用 `profileStorage.deleteProfile(uid)` 删除元数据
- 导致 `isSubscriptionExists()` 方法仍能找到该URL的记录

**解决方案**：
在 `ConfigScreenNew.kt` 的删除逻辑中添加元数据清理：

```kotlin
onDelete = {
    coroutineScope.launch {
        if (profileManager.deleteProfile(file)) {
            // 同时删除元数据，允许再次导入同一订阅
            profileStorage.deleteProfile(uid)
            
            // 如果删除的是当前配置，清空当前配置路径
            if (file.absolutePath == currentConfigPath) {
                settingsManager.setCurrentConfigPath("")
            }
            loadProfiles()
        } else {
            errorMessage = "删除失败"
        }
    }
}
```

**影响的文件**：
- `mobile/app/src/main/java/io/github/clash_verge_rev/clash_verge_rev/ui/ConfigScreenNew.kt`

---

### 2. ✅ 全局模式切换页面失效

**问题描述**：
- 在代理页面切换到全局模式后，切换到其他页面再回来，模式显示恢复为规则模式
- 模式设置没有正确持久化或同步

**根本原因**：
- `ProxyScreen.kt` 中使用 `remember { mutableStateOf(ProxiesState(mode = initialMode)) }` 创建状态
- `initialMode` 是在组件首次创建时根据 `clashMode` 计算的
- 当页面切换后再回来时，`remember` 会保留旧的状态值
- 虽然 `settingsManager.clashMode` 已经更新，但 `proxiesState.mode` 没有同步更新

**解决方案**：
在 `ProxyScreen.kt` 中添加监听 `clashMode` 变化的 `LaunchedEffect`：

```kotlin
// 监听Clash模式变化，同步更新UI状态
LaunchedEffect(clashMode) {
    val newMode = when (clashMode) {
        "global" -> ProxyMode.GLOBAL
        "direct" -> ProxyMode.DIRECT
        else -> ProxyMode.RULE
    }
    if (proxiesState.mode != newMode) {
        proxiesState = proxiesState.copy(mode = newMode)
    }
}
```

**工作原理**：
- 当 `settingsManager.clashMode` 变化时，`LaunchedEffect(clashMode)` 会重新执行
- 将最新的模式值同步到 `proxiesState.mode`
- 确保UI始终显示正确的模式

**影响的文件**：
- `mobile/app/src/main/java/io/github/clash_verge_rev/clash_verge_rev/ui/ProxyScreen.kt`

---

### 3. ✅ 日志删除节点后仍显示

**问题描述**：
- 删除订阅配置（节点）后，日志页面仍然显示运行日志
- 应该在没有配置时清空日志并显示提示信息

**根本原因**：
- `LogScreen.kt` 使用固定的模拟日志，不关心是否有配置存在
- 没有监听当前配置状态

**解决方案**：
1. 监听 `settingsManager.currentConfigPath` 的变化
2. 当配置路径为空时，清空日志并停止生成新日志
3. 优化空状态提示，明确告诉用户需要先导入配置

```kotlin
// 监听配置路径变化
LaunchedEffect(currentConfigPath) {
    if (currentConfigPath.isEmpty()) {
        // 没有配置时清空日志
        logs = emptyList()
    } else {
        // 有配置时显示初始日志
        logs = listOf(
            LogEntry("INFO", "配置已加载: ${currentConfigPath.substringAfterLast("/")}"),
            LogEntry("INFO", "Clash核心已初始化"),
        )
    }
}

// 只在有配置时生成模拟日志
LaunchedEffect(currentConfigPath, logs.size) {
    if (currentConfigPath.isEmpty()) return@LaunchedEffect
    // ... 生成日志的逻辑
}
```

**空状态改进**：
```kotlin
Text(
    text = if (currentConfigPath.isEmpty()) 
        "请先导入配置" 
    else 
        "暂无日志",
    style = MaterialTheme.typography.bodyLarge
)
if (currentConfigPath.isEmpty()) {
    Text(
        text = "导入订阅配置后将显示运行日志",
        style = MaterialTheme.typography.bodySmall
    )
}
```

**影响的文件**：
- `mobile/app/src/main/java/io/github/clash_verge_rev/clash_verge_rev/ui/LogScreen.kt`

---

## 测试建议

### 测试场景1：删除后再导入
1. 导入一个订阅配置
2. 验证导入成功
3. 删除该订阅
4. 尝试再次导入相同的订阅URL
5. **预期结果**：应该能够成功导入，不提示"订阅已存在"

### 测试场景2：模式切换持久化
1. 在代理页面切换到"全局模式"
2. 切换到其他页面（如首页、配置页）
3. 再切换回代理页面
4. **预期结果**：模式仍然显示为"全局模式"

### 测试场景3：日志显示逻辑
1. 启动应用，不导入任何配置
2. 进入日志页面
3. **预期结果**：显示"请先导入配置"提示，无任何日志
4. 返回配置页面，导入一个订阅
5. 再次进入日志页面
6. **预期结果**：显示"配置已加载"等初始日志，并开始生成运行日志
7. 删除该订阅配置
8. 再次进入日志页面
9. **预期结果**：日志已清空，显示"请先导入配置"提示

---

## 附加改进

### 设计系统集成
在修复过程中，还创建了完整的设计系统：

- **位置**：`mobile/app/src/main/java/io/github/clash_verge_rev/clash_verge_rev/ui/theme/Dimensions.kt`
- **内容**：Material Design 3标准的尺寸规范
  - 字体大小（Typography）
  - 间距（Spacing）
  - 内边距（Padding）
  - 图标尺寸（IconSize）
  - 按钮尺寸（Button）
  - 圆角（CornerRadius）
  - 进度条（ProgressBar）
  - 触摸目标（TouchTarget）
  - 安全边距（SafeArea）

- **优势**：
  - 统一的设计语言
  - 响应式适配所有屏幕尺寸（5.8-8.3英寸）
  - 支持无障碍功能
  - 易于维护和更新

- **文档**：`mobile/DESIGN_SYSTEM.md`

---

## 总结

所有问题已修复，主要涉及：
1. 数据同步和清理逻辑
2. 状态管理和响应式更新
3. UI逻辑与数据状态的关联

修复后的代码更加健壮，用户体验得到改善。

